<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ethan Tse">
<meta name="dcterms.date" content="2025-12-22">

<title>An overview of methods in Single-cell RNA-seq – Ethan Tse</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-f93c2b1f3f0577f377aefa4848a86a36.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Ethan Tse</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#challenges" id="toc-challenges" class="nav-link" data-scroll-target="#challenges">Challenges</a></li>
  </ul></li>
  <li><a href="#basic-quality-control-for-count-matrices" id="toc-basic-quality-control-for-count-matrices" class="nav-link" data-scroll-target="#basic-quality-control-for-count-matrices">Basic Quality Control for Count Matrices</a>
  <ul class="collapse">
  <li><a href="#common-qc-metrics" id="toc-common-qc-metrics" class="nav-link" data-scroll-target="#common-qc-metrics">Common QC Metrics</a></li>
  <li><a href="#filtering" id="toc-filtering" class="nav-link" data-scroll-target="#filtering">Filtering</a></li>
  <li><a href="#basic-qc-plots" id="toc-basic-qc-plots" class="nav-link" data-scroll-target="#basic-qc-plots">Basic QC plots</a></li>
  </ul></li>
  <li><a href="#advanced-qc-for-count-matrices" id="toc-advanced-qc-for-count-matrices" class="nav-link" data-scroll-target="#advanced-qc-for-count-matrices">Advanced QC for Count Matrices</a>
  <ul class="collapse">
  <li><a href="#doublet-detection" id="toc-doublet-detection" class="nav-link" data-scroll-target="#doublet-detection">Doublet Detection</a></li>
  </ul></li>
  <li><a href="#normalization" id="toc-normalization" class="nav-link" data-scroll-target="#normalization">Normalization</a></li>
  <li><a href="#feature-selection" id="toc-feature-selection" class="nav-link" data-scroll-target="#feature-selection">Feature Selection</a>
  <ul class="collapse">
  <li><a href="#preamble" id="toc-preamble" class="nav-link" data-scroll-target="#preamble">Preamble</a></li>
  <li><a href="#mean-variance-plot" id="toc-mean-variance-plot" class="nav-link" data-scroll-target="#mean-variance-plot">Mean Variance Plot</a></li>
  <li><a href="#sec:scrna_dispersion" id="toc-sec:scrna_dispersion" class="nav-link" data-scroll-target="#sec\:scrna_dispersion">Dispersion (Seurat)</a></li>
  <li><a href="#variance-stabilizing-transformation" id="toc-variance-stabilizing-transformation" class="nav-link" data-scroll-target="#variance-stabilizing-transformation">Variance Stabilizing Transformation</a></li>
  <li><a href="#pearson-residuals-sctransform-seurat" id="toc-pearson-residuals-sctransform-seurat" class="nav-link" data-scroll-target="#pearson-residuals-sctransform-seurat">Pearson Residuals: scTransform (Seurat)</a></li>
  <li><a href="#deviance" id="toc-deviance" class="nav-link" data-scroll-target="#deviance">Deviance</a></li>
  </ul></li>
  <li><a href="#dimension-reduction" id="toc-dimension-reduction" class="nav-link" data-scroll-target="#dimension-reduction">Dimension Reduction</a>
  <ul class="collapse">
  <li><a href="#principal-component-analysis-pca" id="toc-principal-component-analysis-pca" class="nav-link" data-scroll-target="#principal-component-analysis-pca">Principal Component Analysis (PCA)</a></li>
  </ul></li>
  <li><a href="#neighborhood-graph" id="toc-neighborhood-graph" class="nav-link" data-scroll-target="#neighborhood-graph">Neighborhood Graph</a></li>
  <li><a href="#clustering" id="toc-clustering" class="nav-link" data-scroll-target="#clustering">Clustering</a></li>
  <li><a href="#batch-correction" id="toc-batch-correction" class="nav-link" data-scroll-target="#batch-correction">Batch Correction</a>
  <ul class="collapse">
  <li><a href="#diagnosing-the-quality-of-integration" id="toc-diagnosing-the-quality-of-integration" class="nav-link" data-scroll-target="#diagnosing-the-quality-of-integration">Diagnosing the quality of integration</a></li>
  </ul></li>
  <li><a href="#cell-type-identification" id="toc-cell-type-identification" class="nav-link" data-scroll-target="#cell-type-identification">Cell Type Identification</a></li>
  <li><a href="#differential-gene-expression-analysis" id="toc-differential-gene-expression-analysis" class="nav-link" data-scroll-target="#differential-gene-expression-analysis">Differential Gene Expression Analysis</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">An overview of methods in Single-cell RNA-seq</h1>
  <div class="quarto-categories">
    <div class="quarto-category">biology</div>
    <div class="quarto-category">technical</div>
    <div class="quarto-category">computational biology</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ethan Tse </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 22, 2025</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">December 24, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<p>This article serves as an overview of the <em>current</em> single-cell RNA-seq data analysis landscape. Due to the popularity of two major software packages across R and python - Seurat and Scanpy - this document will focus on the methods implemented by these packages.</p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<section id="challenges" class="level2">
<h2 class="anchored" data-anchor-id="challenges">Challenges</h2>
<section id="pcr-amplification-and-umis" class="level3">
<h3 class="anchored" data-anchor-id="pcr-amplification-and-umis">PCR Amplification and UMIs</h3>
<p>scRNA-seq poses unique challenges over bulk RNA-seq. From a sample preparation level, the low number of mRNA transcripts from individual cells (as opposed to thousands per sample) necessitates more PCR amplification cycles to get sufficient nucleotide material for sequencing <span class="citation" data-cites="townes_feature_2019">[@townes_feature_2019]</span>. Therefore, many <em>read counts</em> are duplicates of original genetic material. In scRNA-seq, it is advantageous to add <strong>unique molecular identifiers (UMIs)</strong> to each molecule before PCR amplification. This allows for computational deconvolution, as all PCR duplicates would share the same UMI and thus can be removed. These de-duplicated read counts are known as <strong>UMI Counts</strong>.</p>
</section>
<section id="compositional-nature-of-rna-seq-data" class="level3">
<h3 class="anchored" data-anchor-id="compositional-nature-of-rna-seq-data">Compositional nature of RNA-seq data</h3>
</section>
</section>
</section>
<section id="basic-quality-control-for-count-matrices" class="level1">
<h1>Basic Quality Control for Count Matrices</h1>
<p>This section covers quality control at the level of raw count matrices. We assume you are working with <strong>filtered</strong> 10X Genomics <code>cellranger</code> aligned output matrices.</p>
<p>By <em>basic quality control</em>, we mean measures such as <strong>mitochondrial content</strong>, <strong>ribosomal content</strong>, <strong>number of reads per cell</strong>, <strong>number of genes per cell</strong>, etc. More advanced QC such as <strong>doublet detection</strong> and <strong>ambient RNA removal</strong> are considered in the next section.</p>
<p>We will describe each of these features, how to compute them in Scanpy, and how they are used to filter cells.</p>
<section id="common-qc-metrics" class="level2">
<h2 class="anchored" data-anchor-id="common-qc-metrics">Common QC Metrics</h2>
<section id="mitochondrial-fraction" class="level3">
<h3 class="anchored" data-anchor-id="mitochondrial-fraction">Mitochondrial Fraction</h3>
<p>Filtering by reads mapping to mitochondrial reads are so common that it deserves its own little section. A high proportion of reads coming from <strong>Mitochondrial DNA</strong> is often taken to be a sign low quality/dying cells.</p>
<p>This metric is calculated on the <strong>raw/UMI counts</strong> on a <strong>per-cell basis</strong>, and is defined as:</p>
<p><span class="math display">\[
\text{Percent counts mt} = \frac{\text{Reads mapping to mtDNA}}{\text{Total Reads in cell}}
\]</span></p>
<p>Depending on if you are doing single-<em>cell</em> or single-<em>nucleus</em> sequencing, you would expect almost none in the latter as the mitochondria are in the cytoplasm.</p>
</section>
<section id="other-common-metrics" class="level3">
<h3 class="anchored" data-anchor-id="other-common-metrics">Other common metrics</h3>
<p>Aside from using reads mapping to mtDNA for QC, in some contexts, ribosomal reads are also considered, albeit less often. There are a set of other common QC metrics that are calculated at the <strong>gene</strong> or <strong>cell</strong> levels, and it is important to distinguish the two.</p>
<p>The following metrics are described in Scanpy’s documentation as well as in the scater paper <span class="citation" data-cites="mccarthy_scater_2017">[@mccarthy_scater_2017]</span>.</p>
</section>
<section id="in-scanpy" class="level3">
<h3 class="anchored" data-anchor-id="in-scanpy">In Scanpy</h3>
<p>In scanpy, the <code>sc.pp.calculate_qc_metrics()</code> function calculates the following <strong>gene-level</strong> QC metrics:</p>
<ul>
<li><code>n_cells_by_counts</code>: number of cells that have at least one read mapping to this gene</li>
<li><code>mean_counts</code>: the mean counts of this gene</li>
<li><code>log1p_mean_counts</code>: the shifted logarithm of the mean counts</li>
<li><code>pct_dropout_by_counts</code>: number of cells that don’t have a read mapping to this gene</li>
<li><code>total_counts</code>: total counts mapping to this gene</li>
<li><code>log1p_total_counts</code>: shifted logarithm of total counts mapping to this gene</li>
</ul>
<p>and <strong>cell-level</strong> QC metrics:</p>
<ul>
<li><code>n_cells_by_counts</code>: number of cells this expression is measured in</li>
<li><code>log1p_n_cells_by_counts</code>: shifted log of <code>n_cells_by_counts</code></li>
<li><code>total_counts</code>: total reads mapping to this cell</li>
<li><code>log1p_total_counts</code>: shifted log of <code>total_counts</code></li>
<li><code>pct_counts_in_top_X_genes</code>: X is the number of genes, so it details what percent of counts in this cell maps to the top X genes. A high value may indicate low library complexity (bad capture of RNA molecules) and other technical artifacts.</li>
<li><code>total_counts_mt</code>: total reads mapping to mtDNA in this cell</li>
<li><code>log1p_total_counts_mt</code>: shifted log of <code>total_counts_mt</code></li>
<li><code>pct_counts_mt</code>: percentage of reads mapping to mtDNA in this cell</li>
</ul>
</section>
</section>
<section id="filtering" class="level2">
<h2 class="anchored" data-anchor-id="filtering">Filtering</h2>
<p>After computing metrics from the raw count matrix, how do you use them filter out low-quality cells? There are two proposed ways: <strong>thresholding</strong> and <strong>dynamic</strong> filtering, both with their strengths and weaknesses.</p>
<section id="threshold-filtering" class="level3">
<h3 class="anchored" data-anchor-id="threshold-filtering">Threshold Filtering</h3>
<p><strong>Thresholding filtering</strong> uses hard cutoffs to filter out potential low-quality cells. For example, you may choose a cutoff, say ≤ 20% mitochondrial content.</p>
</section>
<section id="adaptive-filtering" class="level3">
<h3 class="anchored" data-anchor-id="adaptive-filtering">Adaptive Filtering</h3>
<p><strong>Adaptive filtering</strong> uses the distribution of the metrics to determine outlier cells. This method assumes that most cells are of good quality, and so outliers can be identified from the distribution of cell qualities. One metric to determine if cells are outliers is the <strong>Median Absolute Deviation</strong>, defined as:</p>
<p><span class="math display">\[
\text{MAD} = \text{median}(|x_i - \text{median}(X)|)
\]</span></p>
<p>It is a measure of statistical dispersion like standard deviation, but is used for filtering single cells because it is a <strong>robust statistic</strong>, meaning it is less sensitive to outliers. Since our assumption is that most cells are of good quality, this means that bad quality cells are likely outliers and we don’t want them to affect our measure of dispersion.</p>
<p>The decision rule is as follows:</p>
<p><span class="math display">\[
\text{Outlier} =
\begin{cases}
\text{Yes}, &amp; \text{if } \mathrm{MAD} \geq n \\
\text{No}, &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>where n is some value analogous to how many standard deviations away constitute an outlier. Often, this value is something between 3 (recommended in the OSCA book) and 5 (recommended in the sc-best-practices book).</p>
<p>In studies with many samples and projects, it is increasingly preferable to use this automatic filtering metric.</p>
</section>
</section>
<section id="basic-qc-plots" class="level2">
<h2 class="anchored" data-anchor-id="basic-qc-plots">Basic QC plots</h2>
<p>In many instances, it helps to visualize the relationship between QC metrics to see if the filtering you choose is suitable for your dataset.</p>
<section id="violin-plots-of-common-metrics" class="level3">
<h3 class="anchored" data-anchor-id="violin-plots-of-common-metrics">Violin plots of common metrics</h3>
<p>These plots show the distribution of each metric across all cells.</p>
</section>
</section>
</section>
<section id="advanced-qc-for-count-matrices" class="level1">
<h1>Advanced QC for Count Matrices</h1>
<p>Advanced QC metrics are not always necessary, and depend largely on your scientific question. Nonetheless, they are important and are briefly covered here.</p>
<section id="doublet-detection" class="level2">
<h2 class="anchored" data-anchor-id="doublet-detection">Doublet Detection</h2>
<p><strong>Doublets</strong> are an especially big problem for droplet-based single-cell technologies such as the popular 10X Genomics platform. Doublets are when more than one cell is fed into a bead, and so when sequenced, there will be more genetic material than one would expect from an individual cell.</p>
</section>
</section>
<section id="normalization" class="level1">
<h1>Normalization</h1>
<p>In Seurat, normalization is log-transformation and scaling by some factor (recall that normalization encompasses scaling and transformation).</p>
</section>
<section id="feature-selection" class="level1">
<h1>Feature Selection</h1>
<section id="preamble" class="level2">
<h2 class="anchored" data-anchor-id="preamble">Preamble</h2>
<p><strong>Feature selection</strong> is a process of selecting a subset of features that are “informative” and/or highly varying. In the case of scRNA-seq, it is used to reduce the number of genes (which can be up to 30,000 sequenced per cell) that defines each droplet, thus acting as a form of <strong>dimensionality reduction</strong>. Ideally, this process removes non-informative genes that either mostly zero counts or vary minimally across <em>samples</em>. For experiments that sequence single cells of a given tissue (most common) an underlying assumption is that only a small fraction of genes are informative and biologically varying <span class="citation" data-cites="townes_feature_2019">[@townes_feature_2019]</span>. This is because most gene expression differences are expected to be across tissues.</p>
<p>Feature selection is a very important step, as it helps to identify the variable features that are then used to generate principal components, inform clustering, and therefore cell typing. The Theis lab has benchmarked the impact of feature selection on downstream analyses in this Nature Methods article.</p>
<p>In this section, we will go through several popular methods. As with many things in scRNA analyses, there are many established methods. For a tabular summary, see Table 1.</p>
</section>
<section id="mean-variance-plot" class="level2">
<h2 class="anchored" data-anchor-id="mean-variance-plot">Mean Variance Plot</h2>
<section id="implementation-in-seurat" class="level3">
<h3 class="anchored" data-anchor-id="implementation-in-seurat">Implementation in Seurat</h3>
<p>This is a relatively simple method, published in the original 2015 Seurat paper. The mean and dispersion<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> of each feature is computed. Then, features are binned by average expression and a z-score is calculated for dispersion per bin. This is done to learn which genes are variable, given it is in a range of means. That is, which genes have highly variable dispersion given they are in a set bin of means. Evidently, the number of bins is a crucial parameter to select and document.</p>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>Mean Variance Plot is implemented in both Seurat and Scanpy:</p>
<ul>
<li>Seurat: <code>FindVariableFeatures(selection.method = "mvp")</code></li>
<li>Scanpy: <code>scanpy.pp.highly_variable_genes(batch_key=None, flavor="seurat")</code></li>
</ul>
</section>
</section>
<section id="sec:scrna_dispersion" class="level2">
<h2 class="anchored" data-anchor-id="sec:scrna_dispersion">Dispersion (Seurat)</h2>
<section id="background" class="level3">
<h3 class="anchored" data-anchor-id="background">Background</h3>
<p><strong>NOTE: This method is obsolete, but is included for completeness.</strong> <strong>NOTE: This method has no associated publication. See the code under the <code>DISP</code> function for implementation reference.</strong></p>
</section>
<section id="algorithm-in-seurat" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-in-seurat">Algorithm in Seurat</h3>
<p>This process selects the top n features ranked by dispersion (σ^2/μ), which is related, but not equivalent to using the coefficient of variation (σ/μ), which uses the standard deviation (sd = √σ^2).</p>
</section>
<section id="implementation-1" class="level3">
<h3 class="anchored" data-anchor-id="implementation-1">Implementation</h3>
<p>Mean Variance Plot is implemented in Seurat in <code>FindVariableFeatures(selection.method = "disp")</code>.</p>
</section>
<section id="comments" class="level3">
<h3 class="anchored" data-anchor-id="comments">Comments</h3>
<p>I have not been able to find why VST is recommended over this method. There is a GitHub issue discussing this, but no clear theoretical conclusion to my understanding.</p>
</section>
</section>
<section id="variance-stabilizing-transformation" class="level2">
<h2 class="anchored" data-anchor-id="variance-stabilizing-transformation">Variance Stabilizing Transformation</h2>
<section id="background-1" class="level3">
<h3 class="anchored" data-anchor-id="background-1">Background</h3>
<p><strong>Variance Stabilizing Transformation (VST)</strong> is an applied statistic technique that involves transforming data for visualization (exploratory data analysis) and/or making the data amenable to use regression models. It is a type of method, and there is no single VST method. For example, a log-transform is a VST under some conditions. In bioinformatics, it is a widely applied method in analyzing RNA-sequencing data due to its discrete nature and heteroskedasticity. Its use predates single-cell RNA-seq, being used in popular R packages such as DESeq2 to normalize and visualize bulk RNA-sequencing data.</p>
</section>
<section id="why-is-vst-needed" class="level3">
<h3 class="anchored" data-anchor-id="why-is-vst-needed">Why is VST needed?</h3>
<p>VST is used to model a mean-variance relationship (ex. σ^2 = μ for Poisson and σ^2 = μ + αμ^2 for Negative Binomial) as commonly seen in RNA-seq count data where larger means have larger variances. This is necessary for feature selection through identifying highly variable genes (that is, genes with high variance) as the variance is not directly comparable if it is not constant as a function of the mean. Without applying a VST, genes with higher means (higher expressed) will be selected as they will have, by heteroskedasticity, a higher variance, even if they are actually not biologically varying. A VST is intended to reduce the dependence of the variance on the mean.</p>
</section>
<section id="seurats-version-of-vst" class="level3">
<h3 class="anchored" data-anchor-id="seurats-version-of-vst">Seurat’s version of VST</h3>
<p>It is important to note that in the Seurat workflow, VST for feature selection is <em>independent</em> of normalization (e.g.&nbsp;log-transform and scaling by some factor) because log-transformation fails to adequately account for the mean-variance relationship (especially when that relationship is more complex).</p>
<p>As described in the Cell paper, the mean-variance is learned from the data. The <em>un-normalized</em> counts/UMI are used to compute the mean and variance of each gene, which are then log10-transformed. A non-linear curve is then fitted using a local fitting of polynomials of degree 2 (loess), which serves as a regularized estimator of variance given the mean of a feature. This estimated function can be used to standardize feature counts without removing higher-than-expected variation. That is, a Z-score transformation normalized with a mean-controlled standard deviation:</p>
<p><span class="math display">\[
z_{ij} = \frac{x_{ij} - \bar{x}_i}{\sigma_i}
\]</span></p>
<p>where z_ij is the standardized value of feature i in cell j, x_ij is the raw value of feature i in cell j, {x}_i is the mean raw value for feature i, and σ_i is the expected standard deviation of feature i derived from the global mean-variance fit.</p>
<p>And enforcing clipping for technical outliers:</p>
<p><span class="math display">\[
z_{ij} \le \sqrt{N}
\]</span></p>
<p>where N is the total number of cells.</p>
<p>The resulting variance of these standardized counts represents mean-adjusted variances and can be ranked to select highly variable genes (Seurat default returns the top 2000).</p>
</section>
<section id="availability-and-implementation" class="level3">
<h3 class="anchored" data-anchor-id="availability-and-implementation">Availability and Implementation</h3>
<p>VST is implemented in both Seurat and Scanpy:</p>
<ul>
<li>Seurat: <code>FindVariableFeatures(selection.method = "vst")</code></li>
<li>Scanpy: <code>scanpy.pp.highly_variable_genes(batch_key=None, flavor="seurat_v3" or "seurat_v3_paper")</code></li>
</ul>
</section>
<section id="comments-1" class="level3">
<h3 class="anchored" data-anchor-id="comments-1">Comments</h3>
<p>This method is largely the most common method of finding highly variable genes. In Seurat, an alternative is a newer method: <em>scTransform</em>. In Scanpy, VST is still the most common method as <em>scTransform</em> is not implemented in the package.</p>
</section>
</section>
<section id="pearson-residuals-sctransform-seurat" class="level2">
<h2 class="anchored" data-anchor-id="pearson-residuals-sctransform-seurat">Pearson Residuals: scTransform (Seurat)</h2>
<section id="tldr" class="level3">
<h3 class="anchored" data-anchor-id="tldr">TL;DR</h3>
<p>The method of Pearson residuals fits a negative binomial generalized linear model using sequencing depth as a covariate and takes the Pearson residuals as the normalized UMI counts because residuals are essentially variance unexplained by the model, which in this case is sequencing depth. Thus, the residuals are the “biological variability” of interest.</p>
</section>
<section id="background-2" class="level3">
<h3 class="anchored" data-anchor-id="background-2">Background</h3>
<p>scTransform does not strictly fall under a feature selection method. Rather, it is a <em>normalization</em> method that happens to also help with feature selection. That is, it is largely intended as an alternative to the scaling (e.g.&nbsp;by some library size) and transformation (e.g.&nbsp;by log transform) approach of normalization. The most common is the Shifted Logarithm:</p>
<p><span class="math display">\[
\log\left(\frac{n_{ij}}{S} + 1\right)
\]</span></p>
<p>where n_ij is the raw count of gene i in cell j and S is some scaling factor.</p>
<p>S is often global like S = 10,000, but are sometimes estimated cell-specific factors (e.g.&nbsp;in scran). If S = 1,000,000, then you would get Counts Per Million (CPM). The +1 is called a pseudocount to deal with 0 counts, as you cannot take log(0).</p>
<p>The authors argue that the strengths of this method are:</p>
<ol type="1">
<li>Avoids heuristics of common normalization methods such as pseudocount addition, log-transform.</li>
<li>Do not assume fixed library size for any cell.</li>
<li>Learns mean-variance relationship.</li>
<li>Data-driven VST.</li>
</ol>
<p>In this section, we will focus on the feature selection component of scTransform.</p>
</section>
<section id="algorithm-of-v1-in-seurat" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-of-v1-in-seurat">Algorithm of V1 in Seurat</h3>
<p><strong>NOTE: This section is for V1, which is described in the original paper. There is an updated version V2.</strong></p>
<p>The crux of why scTransform can be used to select HVGs is that it both normalizes the data and performs a variance stabilizing transformation (VST). Loosely, scTransform fits a generalized linear model, specifically a negative binomial regression model to the UMI data. It models the UMI abundance using sequencing depth as a predictor.</p>
<p>The GLM is formalized using a log link function:</p>
<p><span class="math display">\[
\log(\mathbb{E}(x_i)) = \beta_0 + \beta_1 \log_{10}(m)
\]</span></p>
<p>where x_i is the vector of UMI counts assigned to gene i and m is the vector of molecules assigned (sequencing depth) to the cells, j, so m_j = Σ_i x_{ij}.</p>
<p>Negative binomial regression does not have an error term, unlike simple linear regression. We encode the model probabilistically:</p>
<p><span class="math display">\[
P(x_i \mid m) \sim \mathrm{NB}(\mu, \theta) \\
\mu = \exp(\beta_0 + \beta_1 \log_{10}(m))
\]</span></p>
<p>where θ is the overdispersion parameter.</p>
<p>As the paper showed that modeling each gene individually leads to overfitting especially for low-abundance genes due to high variance (an overestimation of true variance), they regularize all model parameters by sharing information across genes. Regularization is conducted in 3 steps:</p>
<ul>
<li>Fit a NB regression model on each gene, estimating the parameters.</li>
<li>Using μ = β_0 + β_1 log(m), use kernel regression estimate to learn global trends in the data. Regularize on a per-parameter basis (i.e.&nbsp;share information across all genes).</li>
<li>Using the regularized parameters, compute the Pearson residuals.</li>
</ul>
<p>Quickly recall what a “normal” residual is: it is the difference between the actual and predicted value:</p>
<p><span class="math display">\[
z_{ij} = x_{ij} - \mu_{ij}
\]</span></p>
<p>Pearson residuals are similar to “normal” residuals from a linear regression, but are scaled by the standard deviation to account for heteroskedasticity:</p>
<p><span class="math display">\[
z_{ij} = \frac{x_{ij} - \mu_{ij}}{\sigma_{ij}}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\sigma_{ij} = \sqrt{\mu_{ij} + \frac{\mu_{ij}^2}{\theta_i}}
\]</span></p>
<p>In scTransform, these z_{ij}, the Pearson residuals, are the normalized UMI counts, as they are the “variance unexplained by technical factors such as library size”.</p>
<p>To reduce the impact of outliers similar to in VST above, the authors enforce:</p>
<p><span class="math display">\[
z_{ij} \le \sqrt{N}
\]</span></p>
<p>where N is the total number of cells.</p>
</section>
<section id="feature-selection-using-sctransform" class="level3">
<h3 class="anchored" data-anchor-id="feature-selection-using-sctransform">Feature Selection using scTransform</h3>
<p>The Pearson residuals transformation doubles as a variance stabilizing transformation, which is what allows scTransform to simultaneously normalize and select features.</p>
<p>With the variance stabilized, the Pearson residuals (aka normalized UMI counts) can be used directly to find HVGs. For each gene, plot the variance of the Pearson residuals z_i. Rank these by variance, and select the top n = 2000. This gives you a list of HVGs.</p>
</section>
<section id="sctransform-v2" class="level3">
<h3 class="anchored" data-anchor-id="sctransform-v2">scTransform V2</h3>
<p>scTransform updated to v2. See the docs.</p>
</section>
<section id="implementation-2" class="level3">
<h3 class="anchored" data-anchor-id="implementation-2">Implementation</h3>
<p>scTransform is implemented in Seurat:</p>
<ul>
<li>Seurat: <code>SCTransform(object, vst.flavor = "v2")</code></li>
</ul>
</section>
<section id="comments-2" class="level3">
<h3 class="anchored" data-anchor-id="comments-2">Comments</h3>
<p>scTransform has been argued to be a poorly specified model. Supporting literature may be this and this paper(s), but I am personally not up to date on this argument. The latter paper motivated the update to scTransform V2.</p>
<p>If you use scTransform, use the updated version: <code>vst.flavor = "v2"</code>.</p>
<p>If you use scTransform, it replaces 3 normalization functions:</p>
<ul>
<li>Log normalization (<code>log(x/10000 + 1)</code>): <code>NormalizeData()</code></li>
<li>Scale and center data (mean = 0, sd = 1): <code>ScaleData()</code></li>
<li>Select HVGs (“mvp”, “vst” etc.): <code>FindVariableFeatures()</code></li>
</ul>
<p>The <code>vars.to.regress</code> option is used to apply a <em>second round</em> of NB regression, in addition to the first, regularized model with sequencing depth.</p>
<p>First: <span class="math display">\[
\log(\mathbb{E}(x_i)) = \beta_0 + \beta_1 \log_{10}(m)
\]</span></p>
<p>Second: <span class="math display">\[
\log(\mathbb{E}(x_i)) = \beta_{0\mathrm{reg}} + \beta_{1\mathrm{reg}} \log_{10}(m) + \beta_2(p)
\]</span></p>
<p>where reg indicates they are fixed, regularized parameters from the first set of regressions, while β_2 can be freely estimated.</p>
</section>
</section>
<section id="deviance" class="level2">
<h2 class="anchored" data-anchor-id="deviance">Deviance</h2>
<section id="background-3" class="level3">
<h3 class="anchored" data-anchor-id="background-3">Background</h3>
<p>As with Pearson Residual methods, a central concern are the effects of the heuristic steps used in common normalization (pseudocount addition, log-transformation) as the choice of the pseudocount is arbitrary and can subtly bias transformed data <span class="citation" data-cites="townes_feature_2019">[@townes_feature_2019]</span>. Townes et al., 2019 argue that the highly variable genes method is susceptible to arbitrary pseudocount addition as very small pseudocount values will increase the variance of genes with zero counts.</p>
<p>Therefore, in this section, we will cover the Deviance method proposed by Townes et al., 2019, which covers both feature selection and dimensionality reduction.</p>
</section>
<section id="what-is-deviance" class="level3">
<h3 class="anchored" data-anchor-id="what-is-deviance">What is Deviance?</h3>
<p><strong>Deviance</strong> is a goodness-of-fit statistic for a statistical model. It generalizes the sum of squared residuals in ordinary least squares to cases where the model is fit using maximum likelihood estimation. It is often used for generalized linear models.</p>
</section>
<section id="deviance-in-scrna-seq" class="level3">
<h3 class="anchored" data-anchor-id="deviance-in-scrna-seq">Deviance in scRNA-seq</h3>
<p><strong>Deviance</strong> is an alternative that, supposedly, is more robust to outliers.</p>
<p>Table 1: Common feature selection methods in scRNA-seq.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Approach</th>
<th>Software</th>
<th>Brief Description</th>
<th>Ref.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VST</td>
<td>S, SCP</td>
<td>Fit curve to Mean-variance</td>
<td><a href="https://www.sciencedirect.com/science/article/pii/S0092867419305598?via%3Dihub">Cell paper</a></td>
</tr>
<tr class="even">
<td>Mean Variance Plot</td>
<td>S, SCP</td>
<td>Rank within-bin dispersion</td>
<td><a href="https://www.nature.com/articles/nbt.3192">Seurat paper</a></td>
</tr>
<tr class="odd">
<td>Dispersion</td>
<td>S, SCP</td>
<td>Rank absolute dispersion</td>
<td><a href="https://rdrr.io/github/satijalab/seurat/src/R/preprocessing5.R">Code</a></td>
</tr>
<tr class="even">
<td>Pearson Residuals</td>
<td>S</td>
<td>Use residuals from NB glm</td>
<td><a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1">V1</a>, <a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02451-7">critique</a>, <a href="https://satijalab.org/seurat/archive/v4.3/sctransform_v2_vignette">V2</a></td>
</tr>
<tr class="odd">
<td>Deviance</td>
<td>SCP</td>
<td>Multinomial Model</td>
<td><a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1861-6">Paper1</a>, <a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02136-7">Paper2</a></td>
</tr>
</tbody>
</table>
<p><em>S = Seurat, SCP = Scanpy.</em></p>
</section>
</section>
</section>
<section id="dimension-reduction" class="level1">
<h1>Dimension Reduction</h1>
<p>This section covers a second round of dimensionality reduction. We first reduced dimensions by identifying HVGs, now we proceed by using <strong>Principal Component Analysis</strong>.</p>
<section id="principal-component-analysis-pca" class="level2">
<h2 class="anchored" data-anchor-id="principal-component-analysis-pca">Principal Component Analysis (PCA)</h2>
<p><strong>PCA</strong> is a linear dimensionality reduction method. Given a covariance matrix, it finds a set of orthonormal basis vectors, termed eigenvectors, and their associated eigenvalues. The eigenvectors are the “new” axes, composed of linear combinations of the original features, and the eigenvalues correspond to the variance explained by the corresponding eigenvector.</p>
<p>In single-cell analysis, we want to compute these “new” axes, which are essentially meta-features designed to maximize variance (of the original dataset) explained, and use them as the new dimensions, often much smaller than the original features.</p>
<p>How do we choose how many of these “new” axes to use? By definition, PCA computes p−1 principal components, where p is the number of features. If we use all the PCs we computed, then we essentially have not reduced the dimension at all.</p>
<p>By convention, most people use the first 50 PCs, but there are ways to check if you need to use more. In Scanpy, you use the Variance Ratio:</p>
<p><span class="math display">\[
\frac{\text{Variance Explained by PC}}{\text{Total Variance Explained by All PCs}}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\sum_{i=1}^p \text{Variance Explained by PC}_i
\]</span></p>
</section>
</section>
<section id="neighborhood-graph" class="level1">
<h1>Neighborhood Graph</h1>
</section>
<section id="clustering" class="level1">
<h1>Clustering</h1>
</section>
<section id="batch-correction" class="level1">
<h1>Batch Correction</h1>
<p>Here, we discuss the dreaded issue in single-cell: <strong>batch effects</strong>. These are technical variations that do not reflect biological differences. The space in which these technical variations can arise in is vast. Commonly described batch effects include different sequencing machines, runs, different technicians, different institutions, etc.</p>
<p>Thus, we need to adjust for these differences before running any integrated analyses.</p>
<section id="diagnosing-the-quality-of-integration" class="level2">
<h2 class="anchored" data-anchor-id="diagnosing-the-quality-of-integration">Diagnosing the quality of integration</h2>
</section>
</section>
<section id="cell-type-identification" class="level1">
<h1>Cell Type Identification</h1>
</section>
<section id="differential-gene-expression-analysis" class="level1">
<h1>Differential Gene Expression Analysis</h1>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Dispersion here is NOT the same as the variance. It refers to the variance-to-mean ratio σ^2/μ, and is mostly used for count data.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/eto168\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<a href="https://github.com/eto168">Ethan Tse</a> ©
<script>document.write(new Date().getFullYear())</script>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>