<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ethan Tse">
<meta name="dcterms.date" content="2025-12-22">

<title>An overview of Proteomics for Cancer Research – Ethan Tse</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-f93c2b1f3f0577f377aefa4848a86a36.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Ethan Tse</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#proteomics" id="toc-proteomics" class="nav-link active" data-scroll-target="#proteomics">Proteomics</a>
  <ul class="collapse">
  <li><a href="#background-and-history" id="toc-background-and-history" class="nav-link" data-scroll-target="#background-and-history">Background and History</a></li>
  <li><a href="#proteomics-workflow-basics" id="toc-proteomics-workflow-basics" class="nav-link" data-scroll-target="#proteomics-workflow-basics">Proteomics Workflow Basics</a></li>
  <li><a href="#sec-hplc" id="toc-sec-hplc" class="nav-link" data-scroll-target="#sec-hplc">High-Performance Liquid Chromatography (HPLC)</a></li>
  <li><a href="#sec-tms" id="toc-sec-tms" class="nav-link" data-scroll-target="#sec-tms">Tandem Mass Spectrometry (MS/MS or MS<sup>2</sup>)</a></li>
  <li><a href="#sec-proteomics_database_search" id="toc-sec-proteomics_database_search" class="nav-link" data-scroll-target="#sec-proteomics_database_search">Identifying Proteins: Database Search</a></li>
  <li><a href="#sec-proteomics_quantification" id="toc-sec-proteomics_quantification" class="nav-link" data-scroll-target="#sec-proteomics_quantification">Quantifying Proteins</a></li>
  <li><a href="#label-free-vs-isotopic-labeling" id="toc-label-free-vs-isotopic-labeling" class="nav-link" data-scroll-target="#label-free-vs-isotopic-labeling">Label-Free vs Isotopic labeling</a></li>
  <li><a href="#how-does-mass-spec-work" id="toc-how-does-mass-spec-work" class="nav-link" data-scroll-target="#how-does-mass-spec-work">How does mass spec work?</a></li>
  <li><a href="#what-is-ms1-and-ms2" id="toc-what-is-ms1-and-ms2" class="nav-link" data-scroll-target="#what-is-ms1-and-ms2">What is MS1 and MS2?</a></li>
  <li><a href="#sec-proteomics_software" id="toc-sec-proteomics_software" class="nav-link" data-scroll-target="#sec-proteomics_software">Proteomics Analysis Software</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">An overview of Proteomics for Cancer Research</h1>
  <div class="quarto-categories">
    <div class="quarto-category">biology</div>
    <div class="quarto-category">technical</div>
    <div class="quarto-category">computational biology</div>
    <div class="quarto-category">proteomics</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ethan Tse </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 22, 2025</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">December 24, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<section id="proteomics" class="level1">
<h1>Proteomics</h1>
<p>The <strong>Proteome</strong> is the total proteins present in a cell, tissue, or organism at a given time. It is more difficult to study than genomics (DNA) because the DNA is generally constant across organisms and time. It is also more difficult to study than transcriptomes (RNA) because<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Despite the many challenges, proteomics is a very informative data modality as it informs us on the presence and quantity of the true effector molecules in biological systems: proteins.</p>
<p>A <a href="https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/0471140864.ps1601s62">great review</a>.</p>
<section id="background-and-history" class="level2">
<h2 class="anchored" data-anchor-id="background-and-history">Background and History</h2>
<p>A good basic introduction is Thermofisher Scientific’s <a href="https://assets.thermofisher.com/TFS-Assets/CMD/brochures/xx-65639-ms-biologist-guide-proteomics-xx65639-en.pdf">A tourist’s guide</a>. A good start is why proteomics? As proteins play a crucial role in the structure and function of biological systems, we need to measure protein abundance relative to the stages of a biological system (e.g.&nbsp;differentiation, response to therapeutic intervention, and cell development). From a technical standpoint, the field often uses mRNA-seq as a surrogate to measure protein expression, primarily due to its relatively low cost, ease of access, and technical simplicity. However, several studies have noted that mRNA expression is only weakly correlated with protein expression, suggesting that mRNA differential expression does not necessarily reflect changes in protein abundance, which would be the true effector molecules.</p>
<p>Proteomics was historically qualitative, but pushes have been made to make it both <strong>qualitative</strong> and <strong>quantitative</strong>. This brings up an important topic to understand: <strong>What’s the difference between traditional and new methods for protein quantification?</strong></p>
<p>A classic method is <strong>western blotting</strong>, which is an immunoassay that is based on antibodies probing proteins. It has a simple protocol and is widely used. However, this method requires <em>a priori</em> knowledge of the system as you need to know which proteins to probe, and why a system would have an expected change in that protein. Another limitation is antibody availability: is that antibody available? Is it optimized? Can we afford a lot of antibodies to screen? Are there antibodies for specific protein modifications? Technical limitations include sample intensity, it is only <em>semi-quantitative</em>, has a linear dynamic range, and typically only characterizes one protein per experiment (though you can strip antibodies and re-probe, but with limitations).</p>
<p>A more modern approach is <strong>liquid chromatography coupled to mass spectrometry (LC-MS)</strong>, which enables system-wide identification and quantification of proteins. It can be used for both discovery (untargeted) and validation (targeted) of protein abundance. Furthermore, it can also be used to probe specific posttranslational modifications (PTMs) and identify the location of the modified residue. Mass spec requires less sample than western blot, and does NOT use antibodies to identify/quantify proteins.</p>
<p>Now, we’ve established that LC-MS can be used for discovery and/or validation. What’s the difference? <strong>Discovery</strong> tries to identify as many proteins as possible while preserving the ability to measure relative protein abundance across samples. It optimizes <strong>protein identification</strong> by spending more time and effort per sample, but analyzes fewer samples. Discovery is most often used to inventory proteins in a sample or detect differences in the abundance of proteins between multiple samples. In contrast, <strong>Validation</strong> optimizes throughput of many (hundreds/thousands) of samples. This allows for high quantitative precision and accuracy. It is used after discovery to quantify specific proteins from the initial screen.</p>
<p>In the following sections, we will discuss the standard proteomic workflow and some variations at a basic level.</p>
</section>
<section id="proteomics-workflow-basics" class="level2">
<h2 class="anchored" data-anchor-id="proteomics-workflow-basics">Proteomics Workflow Basics</h2>
<p>At a surface level, the typical proteomics workflow can be crudely summarized by the following sequential steps (see Figure Figure 1):</p>
<ol type="1">
<li>Protein Extraction</li>
<li>Enzymatic Digestion</li>
<li>Peptide Separation (see the High-Performance Liquid Chromatography (HPLC) section)</li>
<li>Mass Spectrometry (see the Tandem Mass Spectrometry (MS/MS) section)</li>
<li>Protein Identification (see Identifying Proteins: Database Search)</li>
<li>Protein Quantification (see Proteomics Analysis Software)</li>
</ol>
<p><img src="files/proteomics/basic_proteomics_workflow_usfhealth.png" id="fig:basic_proteomics_workflow" class="img-fluid" style="width:100.0%" data-fig-cap="Basic Proteomics Workflow from USF Health"></p>
</section>
<section id="sec-hplc" class="level2">
<h2 class="anchored" data-anchor-id="sec-hplc">High-Performance Liquid Chromatography (HPLC)</h2>
<p><strong>Reference:</strong> <a href="https://www.thermofisher.com/us/en/home/industrial/chromatography/chromatography-learning-center/liquid-chromatography-information/hplc-basics.html?erpType=Global_E1">Tutorial from ThermoFisher Scientific</a></p>
<p><strong>Reference:</strong> <a href="https://www.thermofisher.com/us/en/home/industrial/mass-spectrometry/mass-spectrometry-learning-center/liquid-chromatography-mass-spectrometry-lc-ms-information.html#:~:text=LC%20is%20also%20an%20ideal,gel%20electrophoresis%20for%20molecular%20separation.">ThermoFisher: LC-MS information</a></p>
<p>HPLC is an analytical chemistry technique used to separate compounds in a chemical mixture. The separation is based on using pressure-driven flow of a <strong>mobile phase</strong> through a column packed with a <strong>stationary phase</strong>. The principle is that compounds would separate by how the physiochemical properties of the <strong>analyte</strong> interact with the <strong>mobile phase</strong> and <strong>stationary phase</strong>.</p>
<p>The basic steps are:</p>
<ol type="1">
<li>Mobile phase flows.</li>
<li><strong>Add samples:</strong> inject sample/analyte into the path of the mobile phase.</li>
<li><strong>Separate Compounds:</strong> the mobile phase carries the analyte through the stationary phase, leading to physical separation of compounds.</li>
<li><strong>Analyte Detection:</strong> an electrical signal is generated and you can detect target analytes.</li>
<li><strong>Chromatogram Generation:</strong> detected analyte signals are translated to a chromatogram (retention time vs analyte signal).</li>
</ol>
<p>In the context of proteomics, HPLC is used to separate out proteins and peptides from complex mixtures before running mass spectrometry. It is also very good at separating isomers, molecules with the same formula but different structures. Since mass spectrometers detect mass-to-charge ratio, they have a hard time telling isomers apart since they have the same mass. HPLC can be used to pre-separate them so they can be analyzed separately on the mass spectrometer.</p>
<p>From an analysis perspective, the file output of the HPLC is a <strong>chromatogram</strong>, which is a graph with time on the x-axis and relative abundance on the y-axis. This graph shows the elution profile of the HPLC run and a peak at x = X, y = Y indicates a large amount of material eluted at time X and fed into the subsequent mass spectrometer. For more examples, see figure 16.1.5 in Zhang et al.&nbsp;(2010).</p>
<p>The separated compounds/proteins/peptides are fed into the mass spectrometer in the order that they leave the LC column.</p>
</section>
<section id="sec-tms" class="level2">
<h2 class="anchored" data-anchor-id="sec-tms">Tandem Mass Spectrometry (MS/MS or MS<sup>2</sup>)</h2>
<p><strong>Tandem Mass Spectrometry</strong> (see Figure 2) is an extension of regular mass spectrometry. It uses two or more mass spectrometers to analyze peptides multiple times to improve resolution by separating ions multiple times based on their m/z ratios. This process occurs in roughly three steps: selection — fragmentation — detection.</p>
<p><img src="files/proteomics/tandem_mass_spec_wikipedia.png" id="fig:tms_scheme" class="img-fluid" style="width:50.0%" data-fig-cap="Schematic of Tandem Mass Spectrometry. Source: Wikipedia"></p>
<p>The LC-separated analytes are fed into the first mass spectrometer, MS1, which outputs a resulting <strong>mass spectrum</strong> (see Figure 3). This mass spectrum represents peptide <strong>precursor ions</strong> and is used to select which peptides are fragmented into fragment ions and provided to the second mass spectrometer MS2 to be further analyzed (see the LFQ-DDA and LFQ-DIA sections for the two different ways of selecting). A typical MS/MS run generates sequence-informative fragment ions from a peptide (or many if all identified precursor ions are provided to MS2). Recall from the LC section that compounds are fed into MS1 as they elute from the HPLC column. Therefore, each peptide ion (or more precisely, compounds that elute at the same time from HPLC) gives a mass spectrum.</p>
<p>What are the commonly observed peptide fragments from mass spectrometry? They are primarily produced by cleavage of amide bonds that join two amino acids. A table of commonly observed peptide fragment ions can be found in Zhang et al.&nbsp;(2010).</p>
<p>The output of MS/MS is then subject to database search to identify which proteins the ions are from.</p>
<p><img src="files/proteomics/example_mass_spectrum_broad.png" id="fig:ex_mass_spectrum" class="img-fluid" style="width:50.0%" data-fig-cap="Example Mass Spectrum from the Broad Institute"></p>
</section>
<section id="sec-proteomics_database_search" class="level2">
<h2 class="anchored" data-anchor-id="sec-proteomics_database_search">Identifying Proteins: Database Search</h2>
<p>After identifying the peptide ions from the mass spectra, we need to know which proteins they come from because the primary interest is proteins, not peptides. Database-search algorithms compare observed fragment patterns to theoretical spectra derived from protein sequence databases to assign peptide IDs, which are then rolled up to protein-level identifications.</p>
</section>
<section id="sec-proteomics_quantification" class="level2">
<h2 class="anchored" data-anchor-id="sec-proteomics_quantification">Quantifying Proteins</h2>
<p>Quantifying proteins involves two major strategies: label-free approaches and isotopic labeling.</p>
</section>
<section id="label-free-vs-isotopic-labeling" class="level2">
<h2 class="anchored" data-anchor-id="label-free-vs-isotopic-labeling">Label-Free vs Isotopic labeling</h2>
<p>In proteomics, there is a tradeoff between proteome coverage, sample throughput, method development, and reproducibility and precision. The choice of method is motivated by the biological question. Methods can be split into <strong>isotopic labeling</strong> or <strong>label-free</strong>.</p>
<p>Conceptually, LFQ measures and compares protein abundances using the natural intensity of peptide signals measured by the mass spec. Isotopic labeling methods (SILAC, TMT, iTRAQ) label the peptides, and so quantification and comparisons are done on the <strong>reporter ions</strong>.</p>
<p>First, let’s discuss discovery-focused proteomics pipelines. In these cases, we want to identify and quantify (on a relative scale) the whole proteome. Several discovery techniques are: <strong>stable isotope labelling by amino acids in cell culture (SILAC)</strong>, <strong>chemical labeling with isobaric mass tags</strong>, and <strong>label-free quantitation (LFQ)</strong>.</p>
<p>There are two types of LFQ: data-dependent acquisition (DDA) and data-independent acquisition (DIA). These differ in how the MS2 data is acquired.</p>
<section id="sec-lfq_dda" class="level3">
<h3 class="anchored" data-anchor-id="sec-lfq_dda">LFQ-DDA</h3>
<p>In DDA, ions for a given m/z range are <strong>individually isolated</strong> and fragmented. Quantitation involves extracting peptide chromatograms (MS1 precursor ion) from LC-MS runs and integrating peak areas over the chromatographic time scale or using the intensity at the highest point of the chromatographic peak. The highest peaks and/or largest areas are the identified peptides that trigger MS2 acquisition. MS2 is used to further fragment the ions, allowing peptide identification by comparing to databases using software such as <strong>MaxQuant</strong>. DDA generates <strong>high-quality MS2 spectra that are not chimeric and typically contain one peptide</strong>.</p>
<p>A chromatogram is the output of chromatography: each component ideally produces a peak (retention time vs signal). Signal is proportional to analyte concentration, so quantification can use peak area or peak height.</p>
<p><img src="files/chromatogram_example.png" id="fig:example_chromatography" class="img-fluid" style="width:80.0%" data-fig-cap="Example of a chromatogram from Wikipedia"></p>
<p>After quantifying, you can compare areas and/or intensities across control and experimental samples. LFQ-DDA has good reproducibility and linearity at the peptide and protein levels. Samples are run individually, not pooled.</p>
<p><img src="files/thermofisher_LFQ_DDA.png" id="fig:lfq_dda" class="img-fluid" style="width:50.0%" data-fig-cap="LFQ DDA Workflow from ThermoFisher"></p>
</section>
<section id="sec-lfq_dia" class="level3">
<h3 class="anchored" data-anchor-id="sec-lfq_dia">LFQ-DIA</h3>
<p>In DIA, a precursor mass range is divided into relatively wide (≈ 25 m/z) windows. For each window, the instrument fragments all precursor ions in that window, producing chimeric MS2 spectra that contain fragments from multiple co-isolated peptides. This differs from DDA: instead of isolating one precursor at a time, DIA fragments all precursors in each window. DIA therefore provides MS2 data for <strong>all</strong> detected precursors, improving coverage and reproducibility, but requires specialized software to deconvolve complex spectra.</p>
<p>Quantification still typically relies on extracted chromatograms (MS1 precursors and/or MS2 fragment ions) and integrating peak areas across chromatographic time. Each sample is still run independently.</p>
<p><img src="files/thermofisher_LFQ_DIA.png" id="fig:lfq_dia" class="img-fluid" style="width:50.0%" data-fig-cap="LFQ-DIA Schematic from ThermoFisher"></p>
</section>
<section id="stable-isotope-labeling-by-amino-acids-in-cell-culture-silac" class="level3">
<h3 class="anchored" data-anchor-id="stable-isotope-labeling-by-amino-acids-in-cell-culture-silac">Stable Isotope Labeling by Amino Acids in Cell Culture (SILAC)</h3>
<p>SILAC uses in vivo metabolic incorporation of “heavy” 13C- or 15N-labeled amino acids into the experimental group while control samples use the natural isotopes. These heavier isotopes behave the same chemically and biologically, enabling combined processing (mixing, digestion, LC-MS) while still being distinguishable by mass. Advantages include increased throughput and minimized sample manipulation.</p>
</section>
<section id="tandem-mass-tag-tmt-labeling" class="level3">
<h3 class="anchored" data-anchor-id="tandem-mass-tag-tmt-labeling">Tandem Mass Tag (TMT) labeling</h3>
<p>TMT increases the number of samples that can be analyzed simultaneously (typically 2–16 channels) by using isobaric chemical tags. Each tag has:</p>
<ul>
<li>An MS/MS reporter group</li>
<li>A spacer arm</li>
<li>An amine-reactive group (binds peptide N-termini or lysine residues)</li>
</ul>
<p>See <a href="https://en.wikipedia.org/wiki/Isobaric_labeling">isobaric labeling on Wikipedia</a>.</p>
<p>Each sample is labeled with a distinct isotopic variant of the tag, and labeled samples are mixed and analyzed in one run. The tags are isobaric, so in MS1 they appear as a single peak; during MS2 fragmentation each tag releases a reporter ion whose intensity reflects the relative abundance of the peptide in each original sample. Quantification depends on the purity of the precursor ion population selected for MS2.</p>
</section>
</section>
<section id="how-does-mass-spec-work" class="level2">
<h2 class="anchored" data-anchor-id="how-does-mass-spec-work">How does mass spec work?</h2>
<p>A spectrometer separates and measures spectral components of a physical sample. A mass spectrometer measures the mass-to-charge ratio (m/z) of ions. Samples are ionized, and ions are separated by electric/magnetic fields and then detected. Only ionized particles are detected.</p>
<p>Briefly: extract proteins, digest to peptides, ionize peptides, run mass spectrometry. Each MS scan produces a mass spectrum (not the same as a chromatogram). Spectra are used to query databases for peptide IDs. Thousands of scans yield thousands of spectra. Peptide IDs are aggregated and quantified via peak intensities or spectral counts.</p>
<p><img src="files/mass_spec_pentane.png" id="fig:pentane_mass_spec" class="img-fluid" style="width:50.0%" data-fig-cap="Mass Spec of Pentane. Each line is an ion passing through the mass spec. The tallest line at m/z = 43 is the base peak — Source: LibreTexts chemistry"></p>
</section>
<section id="what-is-ms1-and-ms2" class="level2">
<h2 class="anchored" data-anchor-id="what-is-ms1-and-ms2">What is MS1 and MS2?</h2>
<p>MS1 and MS2 follow from tandem mass spectrometry: the first mass analyzer (MS1) separates ions by m/z; selected precursors are fragmented and analyzed by MS2, which separates fragment ions by m/z and detects them. Ions from MS1 are called precursor ions; ions from MS2 are called fragment ions.</p>
</section>
<section id="sec-proteomics_software" class="level2">
<h2 class="anchored" data-anchor-id="sec-proteomics_software">Proteomics Analysis Software</h2>
<p>Common tools for identification and quantification include MaxQuant, Proteome Discoverer, OpenSWATH, DIA-NN, Spectronaut, MSFragger, and others. Choice depends on acquisition strategy (DDA vs DIA), labeling strategy (LFQ, SILAC, TMT), and downstream analysis requirements.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Not sure yet.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/eto168\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<a href="https://github.com/eto168">Ethan Tse</a> ©
<script>document.write(new Date().getFullYear())</script>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>